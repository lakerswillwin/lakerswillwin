<!DOCTYPE html>
<html 
	lang="CH-zh">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> Database system -  Laneのhome</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://kira.host/assets/Pictures/Others/116359b4ccf19917.jpg"
			type="image/png"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
			
				
<link rel="stylesheet" href="/style.css">

			
		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('https://s21.ax1x.com/2024/08/08/pkzljdH.jpg')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="Laneのhome">
        <img
			src="https://s21.ax1x.com/2024/08/08/pkzljdH.jpg"
			alt="Lane"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://s21.ax1x.com/2024/08/08/pkzljdH.jpg" title="Lane">
			<img
				src="https://s21.ax1x.com/2024/08/08/pkzljdH.jpg"
				alt="Lane"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>32</div>
		<div><span>标签</span>16</div>
		<div><span>分类</span>7</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/index/index.html"
			title="指路楼"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				指路楼
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about/about.html"
			title="本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends.html"
			title="友链"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				友链
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/todolist/index.html"
			title="todolist"
		>
			<i
				class="kirafont
					
						icon-unordered-list
					"
			></i>
			<div class="kira-list-item-content">
				todolist
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="https://wx.mail.qq.com/home/index?sid=zRxMToxhT2suJFZaALhEUwAA#/list/1/1"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://space.bilibili.com/3537107830179843?spm_id_from=333.1007.0.0"
				target="_blank"
				mdui-tooltip="{content: '哔哩哔哩'}"
				style="color: rgb(231, 106, 141); background-color: rgba(231, 106, 141, .15);"
			>
				<i
					class="kirafont
					
						icon-bilibili
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/lakerswillwin/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="/null"
				target="_blank"
				mdui-tooltip="{content: 'Gitee'}"
				style="color: rgb(165, 15, 15); background-color: rgba(165, 15, 15, .15);"
			>
				<i
					class="kirafont
					
						icon-gitee
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/cs课程/">
              cs课程
            </a>
            <span class="category-list-count">15</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/思政课/">
              思政课
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/技术/">
              技术
            </a>
            <span class="category-list-count">8</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/数理课程/">
              数理课程
            </a>
            <span class="category-list-count">4</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/科研训练/">
              科研训练
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/课程经验/">
              课程经验
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/随笔/">
              随笔
            </a>
            <span class="category-list-count">2</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/C/" style="font-size: 20px;">C</a> <a href="/tags/C/" style="font-size: 13.33px;">C++</a> <a href="/tags/ai/" style="font-size: 10px;">ai</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/latex/" style="font-size: 10px;">latex</a> <a href="/tags/math/" style="font-size: 16.67px;">math</a> <a href="/tags/nihao/" style="font-size: 10px;">nihao</a> <a href="/tags/physics/" style="font-size: 10px;">physics</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 10px;">建站</a> <a href="/tags/%E6%80%9D%E6%94%BF/" style="font-size: 10px;">思政</a> <a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 13.33px;">硬件</a> <a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 10px;">科研</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">经验</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			文章归档
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">23</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2025
		<a href="/">Lane</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<center> 浏览量：<span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span>| 访客数：<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> </center>
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="https://s21.ax1x.com/2024/09/25/pAQHLHe.jpg"
				data-sizes="auto"
				alt="Database system"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>Database system</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年02月17日</a>
			<a><i class="kirafont icon-edit-fill"></i>11k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 55 分钟</a>
		</div>
		<h2><span id="导航">导航</span></h2><ul>
<li><a href="#%E5%AF%BC%E8%88%AA">导航</a></li>
<li><a href="#introduction">introduction</a><ul>
<li><a href="#purpose-of-database-system">purpose of database system</a></li>
<li><a href="#characteristics-of-databases">Characteristics of Databases</a></li>
<li><a href="#view-of-data">view of data</a></li>
<li><a href="#data-models">data Models</a></li>
<li><a href="#database-languages">Database languages</a><ul>
<li><a href="#data-definition-langauge%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80">Data Definition Langauge(数据定义语言)</a></li>
<li><a href="#data-manipulation-language%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80">Data Manipulation Language(数据操作语言)</a></li>
</ul>
</li>
<li><a href="#database-design">Database Design</a></li>
<li><a href="#database-engine">Database Engine</a><ul>
<li><a href="#storage-manager">Storage manager</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter2-relational-model">chapter2-Relational Model</a><ul>
<li><a href="#basic-structure">Basic Structure</a><ul>
<li><a href="#attributes">Attributes</a></li>
</ul>
</li>
<li><a href="#keys">keys</a></li>
<li><a href="#relational-algebra">Relational Algebra</a><ul>
<li><a href="#additional-operations">Additional Operations</a></li>
<li><a href="#extended-relational-algebra-operations">Extended Relational-Algebra-Operations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter3-introduction-to-sql">chapter3-introduction to SQL</a><ul>
<li><a href="#data-definition-langauge">Data Definition Langauge</a><ul>
<li><a href="#domain-types-in-sql">Domain Types in SQL</a></li>
<li><a href="#built-in-data-types-in-sql">Built-in Data Types in SQL</a></li>
<li><a href="#create-table-construct">Create Table Construct</a></li>
</ul>
</li>
<li><a href="#basic-query-structure">Basic Query Structure</a><ul>
<li><a href="#the-select-clause">The select clause</a></li>
<li><a href="#the-from-clause">The from clause</a></li>
<li><a href="#natural-join-example">Natural join example</a></li>
<li><a href="#string-operations">string operations</a></li>
<li><a href="#ordering-the-display-of-tuples">Ordering the display of tuples</a></li>
<li><a href="#aggregate-functions">Aggregate Functions</a><ul>
<li><a href="#group-by-clause">group by clause</a></li>
<li><a href="#having-clause">having clause</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nested-subqueries">Nested Subqueries</a><ul>
<li><a href="#set-membership">Set membership</a></li>
<li><a href="#set-comparison">set comparison</a></li>
<li><a href="#test-for-empty-relations">test for empty relations</a></li>
<li><a href="#test-for">Test for</a></li>
</ul>
</li>
<li><a href="#modification-of-the-database">Modification of the Database</a></li>
</ul>
</li>
<li><a href="#chapter4-intermediate-sql">chapter4-intermediate SQL</a><ul>
<li><a href="#joined-relations">joined relations</a></li>
<li><a href="#sql-data-types-and-schemas">SQL Data Types and schemas</a><ul>
<li><a href="#user-defined-types">User-defined types</a></li>
<li><a href="#domains">domains</a></li>
</ul>
</li>
<li><a href="#integrity-constraints">integrity constraints</a><ul>
<li><a href="#not-null-and-unique-constraints">Not NULL and Unique constraints</a></li>
<li><a href="#the-check-clause">the check clause</a></li>
</ul>
</li>
<li><a href="#views">views</a><ul>
<li><a href="#example-views">example views</a></li>
<li><a href="#views-defined-using-other-views">views defined using other views</a></li>
<li><a href="#update-of-a-view">update of a view</a></li>
<li><a href="#view-and-logical-data-dependence">view and logical data dependence</a></li>
</ul>
</li>
<li><a href="#indexes">Indexes</a></li>
<li><a href="#transactions%E4%BA%8B%E5%8A%A1">transactions（事务）</a><ul>
<li><a href="#transaction-properties">transaction properties</a></li>
<li><a href="#transaction-example">transaction example</a></li>
<li><a href="#transaction-operation">transaction operation</a></li>
</ul>
</li>
<li><a href="#autorization%E6%8E%88%E6%9D%83">Autorization(授权)</a><ul>
<li><a href="#authorization-specification-in-sql">authorization specification in SQL</a></li>
<li><a href="#privileges-in-sql">privileges in SQL</a></li>
<li><a href="#revoking-authorization-in-sql">revoking authorization in SQL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter5-advanced-sql">chapter5-advanced SQL</a><ul>
<li><a href="#accessing-sql-from-a-programming-language">Accessing SQL from a programming language</a><ul>
<li><a href="#api">API</a></li>
<li><a href="#jdbc">JDBC</a><ul>
<li><a href="#jdbc-code">JDBC code</a></li>
<li><a href="#prepared-statement">Prepared Statement</a></li>
<li><a href="#metadata">Metadata</a></li>
</ul>
</li>
<li><a href="#odbcopen-database-connectivity">ODBC(open database connectivity)</a><ul>
<li><a href="#odbc-code">ODBC Code</a></li>
<li><a href="#odbc-prepared-statements">ODBC prepared statements</a></li>
</ul>
</li>
<li><a href="#embedded-sql">Embedded SQL</a></li>
</ul>
</li>
<li><a href="#procedural-constructs-in-sql">procedural constructs in SQL</a><ul>
<li><a href="#sql-functions">SQL functions</a></li>
<li><a href="#sql-procedures">SQL procedures</a></li>
<li><a href="#triggers">Triggers</a><ul>
<li><a href="#trigger-example">Trigger example</a></li>
<li><a href="#statement-level-triggers">Statement Level Triggers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter6-e-r-model">chapter6-E-R Model</a><ul>
<li><a href="#e-r-diagram">E-R Diagram</a></li>
</ul>
</li>
<li><a href="#chapter7-relational-database-design">chapter7-Relational Database Design</a><ul>
<li><a href="#deposition">deposition</a></li>
</ul>
</li>
<li><a href="#chapter13-data-storage-structures">chapter13-Data storage structures</a><ul>
<li><a href="#file-organization">File Organization</a><ul>
<li><a href="#fixed-length-records">Fixed-length records</a></li>
<li><a href="#variable-length-records">Variable-length records</a></li>
<li><a href="#organization-of-records-in-files">Organization of records in files</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter14-indexing">chapter14-Indexing</a><ul>
<li><a href="#basic-concepts">Basic Concepts</a></li>
<li><a href="#ordered-indices">Ordered Indices</a></li>
<li><a href="#b-tree-index">B+-Tree Index</a><ul>
<li><a href="#properties-of-b-tree">properties of B+-tree</a></li>
<li><a href="#b-tree-node-structure">B+-Tree Node Structure</a></li>
<li><a href="#b-treeheight-and-size-estimation">B+-tree:height and size estimation</a></li>
<li><a href="#indexing-strings">Indexing strings</a></li>
<li><a href="#non-unique-search-keys">Non-Unique Search keys</a></li>
<li><a href="#b-file-organization">B+-File Organization</a></li>
<li><a href="#indices-on-multiple-keys">Indices on Multiple Keys</a></li>
</ul>
</li>
<li><a href="#bulk-loading-and-bottom-up-build">Bulk Loading and Bottom-Up Build</a></li>
<li><a href="#indexing-in-main-memory">Indexing in Main Memory</a></li>
<li><a href="#indexing-on-flash">Indexing on Flash</a></li>
<li><a href="#write-optimized-indices--%E4%BC%98%E5%8C%96b%E6%A0%91">Write optimized indices–优化B+树</a><ul>
<li><a href="#log-structured-merge-tree">Log Structured Merge Tree</a></li>
<li><a href="#buffer-tree">buffer tree</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter15-query-processing">chapter15-Query Processing</a><ul>
<li><a href="#basic-steps-in-query-processing">Basic steps in query processing</a></li>
<li><a href="#measures-of-query-cost">measures of query cost</a></li>
<li><a href="#selection-operation">selection operation</a><ul>
<li><a href="#file-scan">file scan</a></li>
<li><a href="#selection-using-indices">selection using indices</a></li>
<li><a href="#selections-involving-comparisons">selections involving comparisons</a></li>
</ul>
</li>
<li><a href="#sorting">sorting</a><ul>
<li><a href="#external-sort-merge%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81">external sort-merge(比较重要)</a></li>
</ul>
</li>
<li><a href="#join-operations">join operations</a><ul>
<li><a href="#nested-loop-join">Nested-Loop Join</a></li>
<li><a href="#block-nested-loop-join">block nested-loop join</a></li>
<li><a href="#indexed-nested-loop-join">indexed nested-loop join</a></li>
<li><a href="#merge-join">merge-join</a></li>
<li><a href="#hash-join">hash join</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter16-query-optimization">chapter16-Query Optimization</a><ul>
<li><a href="#generating-equivalent-expressions">Generating equivalent expressions</a><ul>
<li><a href="#transformation-of-relational-expressions">transformation of relational expressions</a></li>
</ul>
</li>
<li><a href="#statictics-for-cost-estimation">statictics for cost estimation</a><ul>
<li><a href="#statistical-information-for-cost-estimation">statistical information for cost estimation</a></li>
<li><a href="#selection-size-estimation">selection size estimation</a></li>
<li><a href="#estimation-of-the-size-of-joins">Estimation of the size of joins</a></li>
</ul>
</li>
<li><a href="#choice-of-evaluation-plans">choice of evaluation plans</a><ul>
<li><a href="#cost-based-join-order-selection">cost-based join-order selection</a></li>
</ul>
</li>
<li><a href="#additional-optimization-techniques">Additional Optimization Techniques</a><ul>
<li><a href="#optimizing-nested-subqueries">Optimizing Nested Subqueries</a></li>
<li><a href="#materialized-views">Materialized views</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chapter-17-transactions">Chapter 17-Transactions</a><ul>
<li><a href="#transaction-concept">Transaction Concept</a></li>
<li><a href="#a-simple-transaction-model">A simple transaction model</a><ul>
<li><a href="#transaction-state">Transaction State</a></li>
</ul>
</li>
<li><a href="#concurrent-executions">Concurrent Executions</a><ul>
<li><a href="#anomalies-in-concurrent-executions">Anomalies in Concurrent Executions</a></li>
<li><a href="#schedules">Schedules</a></li>
</ul>
</li>
<li><a href="#serializability%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96">Serializability（可串行化）</a><ul>
<li><a href="#conflict-serializability">conflict serializability</a></li>
<li><a href="#view-serializability">View Serializability</a></li>
<li><a href="#recoverable-schedules">Recoverable Schedules</a></li>
<li><a href="#cascading-rollbacks">Cascading Rollbacks</a></li>
</ul>
</li>
<li><a href="#transaction-isolation-levels">Transaction Isolation Levels</a></li>
</ul>
</li>
<li><a href="#chapter-18-concurrency-control">Chapter 18-Concurrency Control</a><ul>
<li><a href="#lock-based-protocols">Lock-Based Protocols</a><ul>
<li><a href="#the-two-phase-locking-2pl-protocol">The Two-Phase Locking (2PL) Protocol</a><ul>
<li><a href="#%E5%88%A9%E7%94%A8%E5%89%8D%E9%A9%B1%E5%9B%BE%E5%8F%8D%E8%AF%81%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7">利用前驱图反证协议的正确性</a></li>
</ul>
</li>
<li><a href="#%E7%BB%A7%E7%BB%AD%E6%8E%A2%E7%A9%B62pl">继续探究2PL</a></li>
</ul>
</li>
<li><a href="#implementation-of-locking">implementation of locking</a><ul>
<li><a href="#lock-table">Lock Table</a></li>
<li><a href="#deadlock-handling">Deadlock Handling</a><ul>
<li><a href="#deadlock">Deadlock</a></li>
<li><a href="#handling">Handling</a></li>
</ul>
</li>
<li><a href="#deadlock-detection">Deadlock Detection</a></li>
<li><a href="#deadlock-recovery">Deadlock Recovery</a></li>
<li><a href="#graph-based-protocols">Graph-Based Protocols</a><ul>
<li><a href="#tree-protocol">Tree Protocol</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#multiple-granularity">Multiple Granularity</a><ul>
<li><a href="#level">level</a></li>
<li><a href="#intention-lock-modes">Intention lock Modes</a></li>
</ul>
</li>
<li><a href="#insert-and-delete-operation">Insert and Delete Operation</a></li>
</ul>
</li>
</ul>
<h2><span id="introduction">introduction</span></h2><h3><span id="purpose-of-database-system">purpose of database system</span></h3><ol>
<li>早期database application建立在file systems上有data redundancy,data isolation,difficulty in accessing data等问题。</li>
<li>integrity problems(完整性问题)<br>  在数据库中integrity constraints can be stated explicitly.</li>
<li>Atomicity problems（原子性问题）<br>  在数据库中主要通过恢复功能来解决原子性问题。</li>
<li>concurrent access anomalies（并发访问异常）<br>对于并发操作若不采取任何限制，可能会导致数据混乱。</li>
<li>Security problems</li>
</ol>
<p>数据库系统提供以上问题的解决措施。</p>
<h3><span id="characteristics-of-databases">Characteristics of Databases</span></h3><ul>
<li>data persistence</li>
<li>convenience in accessing data</li>
<li>data integrity</li>
<li>data security</li>
<li>concurrency control for multiple users</li>
<li>failure recovery</li>
</ul>
<h3><span id="view-of-data">view of data</span></h3><ul>
<li>三级抽象databases（Hide the complexities，enhance the adaptation to changes）</li>
<li>主要通过两层map来体现数据库的物理数据独立性和逻辑数据独立性。<ol>
<li>view level</li>
<li>logical level</li>
<li>physical level</li>
</ol>
</li>
</ul>
<h3><span id="data-models">data Models</span></h3><p>most important:Relational Model</p>
<h3><span id="database-languages">Database languages</span></h3><h4><span id="data-definition-langauge数据定义语言">Data Definition Langauge(数据定义语言)</span></h4><ul>
<li>DDL compiler generates a set of table templates stored in a data dictionary</li>
<li>Data dictionary contains metadata</li>
</ul>
<h4><span id="data-manipulation-language数据操作语言">Data Manipulation Language(数据操作语言)</span></h4><ul>
<li><p>SQL:widely used non-procedural language(陈述式语言)</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> instructor.ID <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12345&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3><span id="database-design">Database Design</span></h3><ul>
<li>Entity Relationship Model（实体-联系模型）</li>
<li>Normalization Theory</li>
</ul>
<h3><span id="database-engine">Database Engine</span></h3><h4><span id="storage-manager">Storage manager</span></h4><h2><span id="chapter2-relational-model">chapter2-Relational Model</span></h2><h3><span id="basic-structure">Basic Structure</span></h3><ul>
<li>定义：Formally, given sets D1, D2, …. Dn a relation r is a subset of  D1 x  D2  x … x Dn.Thus, a relation is a set of n-tuples (a1, a2, …, an) where each ai $\in$ Di。也就是说虽然我们可视化展示的是一个列表，但是本质是没有顺序的，因为是一个集合。</li>
<li>A1,A2….An are attributes</li>
<li>R&#x3D;(A1,A2,..,An) is a relation schema</li>
<li>Database shcema – is the logic structure of the database.</li>
</ul>
<h4><span id="attributes">Attributes</span></h4><ol>
<li>The set of allowed values for each attribute is called the domain（域） of the attribute.</li>
<li>通常值是原子的.</li>
<li>在数据库中为每一个域都规定了相同的空值.</li>
</ol>
<h3><span id="keys">keys</span></h3><ul>
<li>定义：K$\in$R.K is a superkey(超健)  of R if values for K are sufficient to identify a <strong>unique tuple</strong> of each possible relation r(R).<ul>
<li>Example:  {ID} and {ID,name} are both superkeys of instructor.（但是名字不是，因为存在重名的情况）</li>
</ul>
</li>
<li>Superkey K is a candidate key(候选健)  if K is minimal.<ul>
<li>Example: {ID} is a candidate key of instructor.</li>
</ul>
</li>
<li>One of the candidate keys is selected to be the primary key（主键）.</li>
<li>Foreign key（外键） constraint  from attribute(s) A  of  relation r1 to the <strong>primary  key</strong>  B  of  relation r2 states that on any database instance, the value of A for each tuple in r1 <strong>must</strong> also be the value of B for some tuple in r2. (参照完整性，类似于外键限制，但是并不一定局限于主键)</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/./databasephoto/i.png" alt="ex.png" class="lazyload"><br>解释：由上面的例子，第三排的course中的dept_name就是外键，因为course中的dept_name和department中的dept_name（是主键）是同一个值，所以course中的dept_name就是外键。<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./databasephoto/waijian.png" alt="waijian" class="lazyload"><br>解释：红色箭头表示参照完整性，黑键则表示外键。</p>
<h3><span id="relational-algebra">Relational Algebra</span></h3><ul>
<li>输入几个关系，通过某个操作得到一个新的关系。</li>
<li>Six basic operations:<ul>
<li>select（横向选择）$\theta$</li>
<li>project（投影某几列，并且结果会去重）$\pi$</li>
<li>union（对两个关系并起来）<ul>
<li>两个关系必须有相同的元数（same number of attributes）</li>
<li>attributes的域需要相容</li>
</ul>
</li>
<li>set difference -</li>
<li>笛卡尔积(表的乘积) x</li>
<li>rename $\rho$ (当对一个关系想做笛卡尔积的时候，可以对其改名再执行笛卡尔积)</li>
</ul>
</li>
</ul>
<h4><span id="additional-operations">Additional Operations</span></h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="/./databasephoto/add.png" alt="add" class="lazyload"></p>
<ul>
<li>自然联结的例子</li>
<li>除法操作<ul>
<li>结果里面的元组与除数元组连接一定在被除的关系中</li>
</ul>
</li>
</ul>
<h4><span id="extended-relational-algebra-operations">Extended Relational-Algebra-Operations</span></h4><ul>
<li><p>Generalized Projection</p>
</li>
<li><p>Aggregate Functions</p>
</li>
</ul>
<h2><span id="chapter3-introduction-to-sql">chapter3-introduction to SQL</span></h2><h3><span id="data-definition-langauge">Data Definition Langauge</span></h3><h4><span id="domain-types-in-sql">Domain Types in SQL</span></h4><ul>
<li>char(n). Fixed length character string, with user-specified length n.（与C语言有差异，因为C语言的字符串的结尾一定为\0，它以字符数组的形式存储，而数据库作为字典直接可以从存储中截取对应长度，不需要额外的标识符）</li>
<li>varchar(n). Variable length character strings, with user-specified maximum length n.</li>
<li>int. Integer (a finite subset of the integers that is machine-dependent).</li>
<li>smallint. Small integer (a machine-dependent subset of the integer domain type).</li>
<li>numeric(p,d). Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point.<br> → number(3,1) allows 44.5 to be store exactly, but neither 444.5 or 0.32</li>
<li>real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision.</li>
<li>float(n). Floating point number, with user-specified precision of at least n digits.</li>
</ul>
<h4><span id="built-in-data-types-in-sql">Built-in Data Types in SQL</span></h4><ul>
<li>date</li>
<li>time</li>
<li>timestamp(data plus time of day)</li>
<li>interval(period of time)</li>
</ul>
<h4><span id="create-table-construct">Create Table Construct</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> instructor (<br> ID <span class="hljs-type">char</span>(<span class="hljs-number">5</span>),<br> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br> dept_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br> salary <span class="hljs-type">numeric</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>))<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> instructor <span class="hljs-keyword">values</span> (‘<span class="hljs-number">10211</span>’, ’Smith’, ’Biology’, <span class="hljs-number">66000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> instructor <span class="hljs-keyword">values</span> (‘<span class="hljs-number">10211</span>’, <span class="hljs-keyword">null</span>, ’Biology’, <span class="hljs-number">66000</span>);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>其实这个插入有误，因为已经定义了不能为空<br></code></pre></td></tr></table></figure>

<ul>
<li>再研究key</li>
<li>not null</li>
<li>primary key(A1,…,An)</li>
<li>foreign key(Am,…An) references r(对于被引用的表如果发生delete或者update，可以进行这四个操作：cascade（那个表的值怎样变，此表的值就怎么变）, restrict（限制不变）, set null, set default)</li>
<li>总结对比<ul>
<li>操作类型 描述 示例场景</li>
<li>CASCADE 被引用表数据变化时，当前表相关数据自动同步变化。 删除部门时自动删除员工记录</li>
<li>RESTRICT 如果当前表有依赖数据，则拒绝被引用表的数据变化。 防止删除仍有员工的部门</li>
<li>SET NULL 被引用表数据变化时，当前表相关外键字段被设置为 NULL。 删除部门时将员工的部门字段置空</li>
<li>SET DEFAULT 被引用表数据变化时，当前表相关外键字段被设置为默认值。 删除部门时将员工的部门字段设为默认</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Declare</span> ID <span class="hljs-keyword">as</span> the <span class="hljs-keyword">primary</span> key <span class="hljs-keyword">for</span> instructor<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> instructor (<br> ID <span class="hljs-type">char</span>(<span class="hljs-number">5</span>),<br> name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br> dept_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br> salary <span class="hljs-type">numeric</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>),<br> <span class="hljs-keyword">primary</span> key (ID),<br> <span class="hljs-keyword">foreign</span> key (dept_name) <span class="hljs-keyword">references</span> department)<br></code></pre></td></tr></table></figure>

<h3><span id="basic-query-structure">Basic Query Structure</span></h3><h4><span id="the-select-clause">The select clause</span></h4><ul>
<li>SQL 大小写不分的</li>
<li>find the names of all instructors<ul>
<li>select name</li>
<li>from instructor</li>
</ul>
</li>
</ul>
<h4><span id="the-from-clause">The from clause</span></h4><ul>
<li>The from clause lists the relations involved in the query<ul>
<li>Corresponds to the Cartesian product operation of the relational algebra</li>
</ul>
</li>
</ul>
<h4><span id="natural-join-example">Natural join example</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> instructor, teaches<br><span class="hljs-keyword">where</span> instructor.ID <span class="hljs-operator">=</span> teaches.ID;<br><br><span class="hljs-keyword">select</span> name, course_id<br><span class="hljs-keyword">from</span> instructor <span class="hljs-keyword">natural</span> <span class="hljs-keyword">join</span> teaches;<br></code></pre></td></tr></table></figure>

<h4><span id="string-operations">string operations</span></h4><h4><span id="ordering-the-display-of-tuples">Ordering the display of tuples</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name <span class="hljs-keyword">desc</span><span class="hljs-operator">/</span><span class="hljs-keyword">asc</span><br>我们也可以使用limit来得到选择结果<br>limit <span class="hljs-keyword">offset</span>,row_count<br>limit row_count<br></code></pre></td></tr></table></figure>

<h4><span id="aggregate-functions">Aggregate Functions</span></h4><ul>
<li>聚合函数的使用<ul>
<li>直接使用聚合函数：适用于对整个表或满足某些条件的数据进行聚合操作。</li>
<li>结合 GROUP BY 使用聚合函数：适用于按某个字段分组后对每组分别进行聚合操作。</li>
<li>因此，是否需要 GROUP BY 取决于具体的业务需求。如果只是对整体数据进行统计，无需分组；如果需要按某些字段分组统计，则必须使用 GROUP BY。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">Find the average salary <span class="hljs-keyword">of</span> instructors <span class="hljs-keyword">in</span> the Computer Science department<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span> (salary)<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> dept_name<span class="hljs-operator">=</span> ’Comp. Sci.’;<br>Find the total number <span class="hljs-keyword">of</span> instructors who teach a course <span class="hljs-keyword">in</span> the <br>Spring <span class="hljs-number">2010</span> semester<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-keyword">distinct</span> ID)<br><span class="hljs-keyword">from</span> teaches<br><span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> ’Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2010</span><br>Find the number <span class="hljs-keyword">of</span> tuples <span class="hljs-keyword">in</span> the course relation<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> course;<br></code></pre></td></tr></table></figure>

<h5><span id="group-by-clause">group by clause</span></h5><ul>
<li>当我们使用group by的时候是一个聚合操作，所以最终的的select的结果也是以组的形式存在</li>
<li>ex<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./databasephoto/group.png" alt="group" class="lazyload"></li>
</ul>
<h5><span id="having-clause">having clause</span></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">predicates <span class="hljs-keyword">in</span> the <span class="hljs-keyword">having</span> clause <span class="hljs-keyword">are</span> applied after the <br> formation <span class="hljs-keyword">of</span> <span class="hljs-keyword">groups</span> whereas predicates <span class="hljs-keyword">in</span> the <span class="hljs-keyword">where</span><br> clause <span class="hljs-keyword">are</span> applied before forming <span class="hljs-keyword">groups</span><br><span class="hljs-keyword">select</span> dept_name, <span class="hljs-built_in">count</span> (<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> cnt<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;=</span><span class="hljs-number">100000</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_name<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span> (<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> cnt;<br></code></pre></td></tr></table></figure>

<h3><span id="nested-subqueries">Nested Subqueries</span></h3><h4><span id="set-membership">Set membership</span></h4><ul>
<li>通过in和not in来实现嵌套操作</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Find courses offered <span class="hljs-keyword">in</span> Fall <span class="hljs-number">2009</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span> Spring <span class="hljs-number">2010</span><br><br><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> course_id<br><span class="hljs-keyword">from</span> section<br><span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> ’Fall’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span><span class="hljs-operator">=</span> <span class="hljs-number">2009</span> <span class="hljs-keyword">and</span> <br> course_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> course_id<br> <span class="hljs-keyword">from</span> section<br> <span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> ’Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span><span class="hljs-operator">=</span> <span class="hljs-number">2010</span>);<br></code></pre></td></tr></table></figure>

<h4><span id="set-comparison">set comparison</span></h4><ul>
<li>利用some和all与给定集合进行比较</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">some</span> (<span class="hljs-keyword">select</span> salary<br> <span class="hljs-keyword">from</span> instructor<br> <span class="hljs-keyword">where</span> dept_name <span class="hljs-operator">=</span> ’Biology’);<br><br> <span class="hljs-keyword">select</span> name<br><span class="hljs-keyword">from</span> instructor<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span> (<span class="hljs-keyword">select</span> salary<br> <span class="hljs-keyword">from</span> instructor<br> <span class="hljs-keyword">where</span> dept_name <span class="hljs-operator">=</span> ’Biology’);<br></code></pre></td></tr></table></figure>

<h4><span id="test-for-empty-relations">test for empty relations</span></h4><ul>
<li>利用exists和not exists</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">Yet another way <span class="hljs-keyword">of</span> specifying the query “Find <span class="hljs-keyword">all</span> courses taught <br><span class="hljs-keyword">in</span> <span class="hljs-keyword">both</span> the Fall <span class="hljs-number">2009</span> semester <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span> the Spring <span class="hljs-number">2010</span> semester”<br> <span class="hljs-keyword">select</span> course_id<br> <span class="hljs-keyword">from</span> section <span class="hljs-keyword">as</span> S<br> <span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> ’Fall’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span><span class="hljs-operator">=</span> <span class="hljs-number">2009</span> <span class="hljs-keyword">and</span> <br> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">from</span> section <span class="hljs-keyword">as</span> T<br> <span class="hljs-keyword">where</span> semester <span class="hljs-operator">=</span> ’Spring’ <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span><span class="hljs-operator">=</span> <span class="hljs-number">2010</span> <br> <span class="hljs-keyword">and</span> S.course_id<span class="hljs-operator">=</span> T.course_id);<br></code></pre></td></tr></table></figure>

<h4><span id="test-for">Test for</span></h4><h3><span id="modification-of-the-database">Modification of the Database</span></h3><h2><span id="chapter4-intermediate-sql">chapter4-intermediate SQL</span></h2><h3><span id="joined-relations">joined relations</span></h3><ul>
<li>join types<ul>
<li>inner join（默认的笛卡尔积均是inner join）</li>
<li>left outer join（from后面的表的所有列均保留，如果没有成功连接上，则置为NULL）</li>
<li>right outer join（join后面的表的所有列均保留）</li>
<li>full outer join</li>
</ul>
</li>
<li>join conditions<ul>
<li>natural join(自然连接)</li>
<li>on condition(条件连接)</li>
<li>using(A1,…,An)(等值连接)</li>
</ul>
</li>
<li>example<ul>
<li>统计每个老师教的课程（但是可能包含没有课程的老师）<ul>
<li>select id,count(course_id)</li>
<li>from instructor natural left outer join teaches</li>
<li>group by id;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="sql-data-types-and-schemas">SQL Data Types and schemas</span></h3><h4><span id="user-defined-types">User-defined types</span></h4><ul>
<li>create type construct in SQL creates user-defined type<ul>
<li>create type Dollars as numeric(12,2) final</li>
</ul>
</li>
</ul>
<h4><span id="domains">domains</span></h4><ul>
<li>domain is a user-defined type that specifies a set of values and a set of constraints on the values in the set.domains相比于types，domain可以定义一些约束，比如长度，范围，正则表达式等。<ul>
<li>craete domain person_name char(20) not null</li>
</ul>
</li>
</ul>
<h3><span id="integrity-constraints">integrity constraints</span></h3><h4><span id="not-null-and-unique-constraints">Not NULL and Unique constraints</span></h4><h4><span id="the-check-clause">the check clause</span></h4><h3><span id="views">views</span></h3><ul>
<li>A view provides a mechanism to hide certain data<br>from the view of certain users.(虚拟的表，没有实际存在)</li>
<li>好处：简化复杂性，适应能力增加，提供安全权限管理功能。</li>
</ul>
<h4><span id="example-views">example views</span></h4><ul>
<li>a view of instructors without their salary<ul>
<li>create view faculty as<br>  select ID, name, dept_name<br>  from instructor;</li>
<li>当我们创建好这个view以后，我们可以把这个view当作实体的表进行表的各种操作</li>
</ul>
</li>
</ul>
<h4><span id="views-defined-using-other-views">views defined using other views</span></h4><ul>
<li>在定义view的基础上，可以再定义一个view</li>
<li>create view physics_fall_2009 as<br>  select course.course_id, sec_id, building, room_number<br>  from course, section<br>  where course.course_id &#x3D; section.course_id<br> and course.dept_name &#x3D; ’Physics’<br> and section.semester &#x3D; ’Fall’<br> and section.year &#x3D; ’2009’;</li>
<li>create view physics_fall_2009_watson as<br>  select course_id, room_number<br>  from physics_fall_2009<br>  where building&#x3D; ’Watson’;</li>
<li>这样的操作其实我们可以在一个语句中实现<br>select course_id, room_number<br>from physics_fall_2009(已经创建的view)<br>where building&#x3D; ’Watson’;<br> →<br>select course_id, room_number<br>from (select course.course_id, building, room_number<br> from course, section<br> where course.course_id &#x3D; section.course_id<br> and course.dept_name &#x3D; ’Physics’<br> and section.semester &#x3D; ’Fall’<br> and section.year &#x3D; ’2009’)（把view创建的语句嵌套在from中）<br> where building&#x3D; ’Watson’;<br>→<br> select course_id, room_number<br> from course, section<br> where course.course_id &#x3D; section.course_id<br> and course.dept_name &#x3D; ’Physics’<br> and section.semester &#x3D; ’Fall’<br> and section.year &#x3D; ’2009’<br> and building&#x3D; ’Watson’;（sql本质运行的一种语句）</li>
</ul>
<h4><span id="update-of-a-view">update of a view</span></h4><ul>
<li>view相当于只是打开一扇窗，所以对view的修改，实际上是对view的表进行修改。当然孙老师说，为了提高查询的高效性，有些时候确实会创建一个临时表(materialized view)。</li>
<li>example<br>insert into faculty values (’30765’, ’Green’, ’Music’);<br>insert into instructor values (’30765’, ’Green’, ’Music’, null);</li>
<li>但是有些时候view的update不能被翻译为对原始表的独立的操作，因为这个view选取的元素可能不是超键。</li>
</ul>
<h4><span id="view-and-logical-data-dependence">view and logical data dependence</span></h4><ul>
<li>当我们底层的物理数据发生变化，比如一个表分成了两个表，因为我们用户层面可能用到原来的表，那么我们可以利用现在的两个表生成一个代表原来表的view，对于用户层面没有任何变化，但是底层逻辑发生改变。</li>
</ul>
<h3><span id="indexes">Indexes</span></h3><h3><span id="transactions事务">transactions（事务）</span></h3><ul>
<li>在数据库系统中，事务是指一组操作的集合，这些操作要么全部执行成功，要么全部不执行，以确保数据的一致性和完整性。</li>
</ul>
<h4><span id="transaction-properties">transaction properties</span></h4><ul>
<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的所有操作要么都做，要么都不做。</li>
<li>一致性（Consistency）：事务必须使数据库从一个一致状态变换到另一个一致状态。如果事务执行成功，则数据库处于一致状态；如果事务执行失败，则数据库应恢复到事务开始前的状态。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行结果。每个事务都应该独立运行，就好像它是唯一正在运行的事务一样。</li>
<li>持久性（Durability）：一旦事务提交，它对数据库的更改应该是永久性的，即使系统发生故障。</li>
</ul>
<h4><span id="transaction-example">transaction example</span></h4><p> SET AUTOCOMMIT&#x3D;0;<br> UPDATE account SET balance&#x3D;balance -100 WHERE ano&#x3D;‘1001’;<br> UPDATE account SET balance&#x3D;balance+100 WHERE ano&#x3D;‘1002’;<br> COMMIT;（上一条事务结束，下一个事务开始）<br> UPDATE account SET balance&#x3D;balance -200 WHERE ano&#x3D;‘1003’;<br> UPDATE account SET balance&#x3D;balance+200 WHERE ano&#x3D;‘1004’;<br> COMMIT;<br> UPDATE account SET balance&#x3D;balance+balance*2.5%;<br> COMMIT;</p>
<h4><span id="transaction-operation">transaction operation</span></h4><ul>
<li>BEGIN TRANSACTION; 或 START TRANSACTION;：显式地开始一个新的事务。</li>
<li>COMMIT;：提交当前事务，使其所有更改永久生效。</li>
<li>ROLLBACK;：回滚当前事务，撤销所有未提交的更改，是数据库恢复到事务开始之前的状态。</li>
<li>SAVEPOINT savepoint_name;：设置一个保存点，可以在部分回滚时使用。</li>
<li>ROLLBACK TO savepoint_name;：回滚到指定的保存点，而不是整个事务。</li>
</ul>
<h3><span id="autorization授权">Autorization(授权)</span></h3><h4><span id="authorization-specification-in-sql">authorization specification in SQL</span></h4><ul>
<li>the grant statement is used to confer authorization:grant (privilege list) on (relation name or view name) to (user list)</li>
<li>user list:<ul>
<li>user-id</li>
<li><strong>public</strong>,which allows all valid the privilege granted</li>
<li>a role(more on this later)，作用周期是永久性的，角色也就是用户的集合，可以创建角色，然后给角色授予权限。</li>
</ul>
</li>
</ul>
<h4><span id="privileges-in-sql">privileges in SQL</span></h4><p>grant select on instructor to U1, U2, U3<br>grant select on department to public<br>grant update (budget) on department to U1,U2<br>grant all privileges on department to U1</p>
<h4><span id="revoking-authorization-in-sql">revoking authorization in SQL</span></h4><ul>
<li>the revoke statement is used to revoke authorization:revoke (privilege list) on (relation name or view name) from (user list)</li>
</ul>
<h2><span id="chapter5-advanced-sql">chapter5-advanced SQL</span></h2><h3><span id="accessing-sql-from-a-programming-language">Accessing SQL from a programming language</span></h3><ul>
<li>two approaches to access database<ul>
<li>API</li>
<li>Embedded SQL</li>
</ul>
</li>
</ul>
<h4><span id="api">API</span></h4><ul>
<li>ODBC works with C,C++,C#</li>
<li>JDBC works with Java<ul>
<li>Open a connection</li>
<li>Create a “statement” object</li>
<li>Execute queries using the Statement object to send queries and fetch results</li>
<li>Exception mechanism to handle errors</li>
</ul>
</li>
<li>Embedded SQL in C</li>
<li>SQLC-embedded SQL in Java</li>
<li>JPA-OR mapping of Java</li>
</ul>
<h4><span id="jdbc">JDBC</span></h4><h5><span id="jdbc-code">JDBC code</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：stmt为创建的对象</span><br><span class="hljs-comment">//Update to database</span><br><span class="hljs-keyword">try</span> &#123;<br> stmt.executeUpdate(<br> <span class="hljs-string">&quot;insert into instructor values(’77987’, ’Kim’, ’Physics’, 98000)&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (SQLException sqle)<br>&#123;<br> System.out.println(<span class="hljs-string">&quot;Could not insert tuple. &quot;</span> + sqle);<br>&#125;<br><br><span class="hljs-comment">//Execute query and fetch and print results</span><br><span class="hljs-comment">//注意我们返回的是一个集合，是无序的</span><br> <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rset</span> <span class="hljs-operator">=</span> stmt.executeQuery(<br> <span class="hljs-string">&quot;select dept_name, avg (salary)</span><br><span class="hljs-string"> from instructor</span><br><span class="hljs-string"> group by dept_name&quot;</span>);<br><span class="hljs-keyword">while</span> (rset.next()) &#123;<br> System.out.println(rset.getString(<span class="hljs-string">&quot;dept_name&quot;</span>) + <span class="hljs-string">&quot; &quot;</span> +<br> rset.getFloat(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h5><span id="prepared-statement">Prepared Statement</span></h5><ul>
<li>先生成，类型未知，再利用set语句和update语句进行更新</li>
<li>prepared statement也可以避免SQL注入攻击，因为我们提前进行编译，就会防止产生SQL的歧义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pStmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(<br> <span class="hljs-string">&quot;insert into instructor values(?,?,?,?)&quot;</span>);<br>pStmt.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;88877&quot;</span>); pStmt.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Perry&quot;</span>);<br>pStmt.setString(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Finance&quot;</span>); pStmt.setInt(<span class="hljs-number">4</span>, <span class="hljs-number">125000</span>);<br>pStmt.executeUpdate(); <br>pStmt.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;88878&quot;</span>);<br>pStmt.executeUpdate();<br></code></pre></td></tr></table></figure>

<h5><span id="metadata">Metadata</span></h5><ul>
<li>JDBC可以利用getMetaData()方法来获取数据库的元数据，比如列名，列类型，列数目等。</li>
</ul>
<h4><span id="odbcopen-database-connectivity">ODBC(open database connectivity)</span></h4><h5><span id="odbc-code">ODBC Code</span></h5><ul>
<li>完全通过函数调用实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ODBCexample</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> RETCODE error;<br> HENV env; <span class="hljs-comment">/* environment */</span> <br> HDBC conn; <span class="hljs-comment">/* database connection */</span> <br> <span class="hljs-built_in">SQLAllocEnv</span>(&amp;env);<br> <span class="hljs-built_in">SQLAllocConnect</span>(env, &amp;conn);<br> <span class="hljs-built_in">SQLConnect</span>(conn,<span class="hljs-string">&quot;db.yale.edu&quot;</span>, SQL_NTS, <span class="hljs-string">&quot;avi&quot;</span>, SQL_NTS, <span class="hljs-string">&quot;avipasswd&quot;</span>, SQL_NTS); <br> &#123; …. Do actual work … &#125;<br> <span class="hljs-built_in">SQLDisconnect</span>(conn); <br> <span class="hljs-built_in">SQLFreeConnect</span>(conn); <br> <span class="hljs-built_in">SQLFreeEnv</span>(env); <br> &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>main body</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> deptname[<span class="hljs-number">80</span>];<br><span class="hljs-type">float</span> salary;<br><span class="hljs-type">int</span> lenOut1, lenOut2;<br>HSTMT stmt;<br><span class="hljs-type">char</span> * sqlquery = <span class="hljs-string">&quot;select dept_name, sum (salary)</span><br><span class="hljs-string"> from instructor</span><br><span class="hljs-string"> group by dept_name&quot;</span>;<br><span class="hljs-built_in">SQLAllocStmt</span>(conn, &amp;stmt);<br>error = <span class="hljs-built_in">SQLExecDirect</span>(stmt, sqlquery, SQL_NTS);<br><span class="hljs-keyword">if</span> (error == SQL SUCCESS) &#123;<br>  <span class="hljs-comment">//将数据库中的列与C语言中的变量绑定</span><br> <span class="hljs-built_in">SQLBindCol</span>(stmt, <span class="hljs-number">1</span>, SQL_C_CHAR, deptname , <span class="hljs-number">80</span>, &amp;lenOut1);<br> <span class="hljs-built_in">SQLBindCol</span>(stmt, <span class="hljs-number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="hljs-number">0</span> , &amp;lenOut2);<br> <span class="hljs-keyword">while</span> (<span class="hljs-built_in">SQLFetch</span>(stmt) == SQL_SUCCESS) &#123;<br> <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot; %s %g\n&quot;</span>, deptname, salary);<br> &#125;<br>&#125;<br><span class="hljs-built_in">SQLFreeStmt</span>(stmt, SQL_DROP)<br></code></pre></td></tr></table></figure>

<h5><span id="odbc-prepared-statements">ODBC prepared statements</span></h5><h4><span id="embedded-sql">Embedded SQL</span></h4><h3><span id="procedural-constructs-in-sql">procedural constructs in SQL</span></h3><h4><span id="sql-functions">SQL functions</span></h4><ul>
<li>定义函数后再调用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">function</span> dept_count (dept_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>))<br> <span class="hljs-keyword">returns</span> <span class="hljs-type">integer</span><br> <span class="hljs-keyword">begin</span><br> <span class="hljs-keyword">declare</span> d_count <span class="hljs-type">integer</span>;<br> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-operator">*</span> ) <span class="hljs-keyword">into</span> d_count<br> <span class="hljs-keyword">from</span> instructor<br> <span class="hljs-keyword">where</span> instructor.dept_name <span class="hljs-operator">=</span> dept_name<br> <span class="hljs-keyword">return</span> d_count;<br> <span class="hljs-keyword">end</span><br> <span class="hljs-keyword">select</span> dept_name, budget<br> <span class="hljs-keyword">from</span> department<br> <span class="hljs-keyword">where</span> dept_count (dept_name ) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4><span id="sql-procedures">SQL procedures</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">The dept_count <span class="hljs-keyword">function</span> could instead be written <span class="hljs-keyword">as</span> <span class="hljs-keyword">procedure</span>:<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> dept_count_proc (<span class="hljs-keyword">in</span> dept_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>), <br> <span class="hljs-keyword">out</span> d_count <span class="hljs-type">integer</span>)<br><span class="hljs-keyword">begin</span><br> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">into</span> d_count<br> <span class="hljs-keyword">from</span> instructor<br> <span class="hljs-keyword">where</span> instructor.dept_name <span class="hljs-operator">=</span> dept_count_proc.dept_name<br> <span class="hljs-keyword">end</span><br><br>Procedures can be invoked either <span class="hljs-keyword">from</span> an <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">procedure</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">from</span> embedded <span class="hljs-keyword">SQL</span>, <span class="hljs-keyword">using</span> the <span class="hljs-keyword">call</span> statement.<br><br><span class="hljs-keyword">declare</span> d_count <span class="hljs-type">integer</span>;<br><span class="hljs-keyword">call</span> dept_count_proc( ‘Physics’, d_count);<br><br>Procedures <span class="hljs-keyword">and</span> functions can be invoked also <span class="hljs-keyword">from</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">SQL</span><br></code></pre></td></tr></table></figure>

<h4><span id="triggers">Triggers</span></h4><ul>
<li>A trigger is a statement that is executed automatically by the system as a side effect of a modification to the database.</li>
<li>ECA rule<ul>
<li>Event: A modification to the database(insert,delete,update)</li>
<li>Condition: A condition that must be satisfied for the trigger to execute</li>
<li>Action: An action to be performed when the condition is satisfied</li>
</ul>
</li>
</ul>
<h5><span id="trigger-example">Trigger example</span></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">&quot;记录大额交易的表&quot;<br>account_log(account, amount, datetime)<br>&quot;记录大额交易的触发器&quot;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> account_trigger after <span class="hljs-keyword">update</span> <span class="hljs-keyword">of</span> account <span class="hljs-keyword">on</span> balance<br><span class="hljs-keyword">referencing</span> <span class="hljs-keyword">new</span> <span class="hljs-type">row</span> <span class="hljs-keyword">as</span> nrow <br><span class="hljs-keyword">referencing</span> <span class="hljs-keyword">old</span> <span class="hljs-type">row</span> <span class="hljs-keyword">as</span> orow<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">when</span> nrow.balance <span class="hljs-operator">-</span> orow.balance <span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span><span class="hljs-number">200000</span> <span class="hljs-keyword">or</span> <br>     orow.balance <span class="hljs-operator">-</span>nrow.balance <span class="hljs-operator">&gt;=</span><span class="hljs-number">50000</span><br><span class="hljs-keyword">begin</span> <br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account_log <span class="hljs-keyword">values</span> (nrow.account<span class="hljs-operator">-</span>number, <br> nrow.balance<span class="hljs-operator">-</span>orow.balance , <span class="hljs-built_in">current_time</span>() )<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5><span id="statement-level-triggers">Statement Level Triggers</span></h5><h2><span id="chapter6-e-r-model">chapter6-E-R Model</span></h2><h3><span id="e-r-diagram">E-R Diagram</span></h3><ul>
<li>section:弱实体，自己的属性不能表示唯一的实体，所以通过sec_course等relationship，则可以表示section依赖course等，就能够唯一确定section。我们也发现section的某个属性下方为虚线，它需要与它所依赖的主键组合起来成为主键。</li>
</ul>
<h2><span id="chapter7-relational-database-design">chapter7-Relational Database Design</span></h2><h3><span id="deposition">deposition</span></h3><ul>
<li>因为我们想要获得更小的表，所以要将原来的relation进行分解，但是此时分解存在两种情况:<ul>
<li>lossy decomposition: 丢失一些信息，分解后的表通过natural join以后不能重构得到原来的表。</li>
<li>lossless decomposition:$\pi_{R_1}(r) \natural \pi_{R_2}(r) &#x3D; r $</li>
<li>lossless decomposition的充要条件是至少满足以下两个条件之一:R1与R2的交集为R1的超键，或者R1与R2的交集为R2的超键。</li>
</ul>
</li>
</ul>
<h2><span id="chapter13-data-storage-structures">chapter13-Data storage structures</span></h2><h3><span id="file-organization">File Organization</span></h3><h4><span id="fixed-length-records">Fixed-length records</span></h4><ul>
<li>所有记录的长度都相等，当发生删除时：<ul>
<li>move records i + 1, . . ., n to i, . . . , n – 1</li>
<li>move record n to i</li>
<li>do not move records, but link all free records on a free list</li>
</ul>
</li>
</ul>
<h4><span id="variable-length-records">Variable-length records</span></h4><ul>
<li>Attributes are stored in order</li>
<li>Variable length attributes represented by fixed size (offset, length), with actual data stored after all fixed length attributes</li>
<li>Null values represented by null-value bitmap（空位图）<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database1.png" alt="database1" class="lazyload"><br>解释：这上面是一个例子，不定长的保存在后面，定长的与(offset,length)保存在前面。在这个例子中，null bitmap表示前面四个属性都是非空的。</li>
<li>存储variable-length records采用slotted page structure，whose header contains:<ul>
<li>number of record entries</li>
<li>end of free space in the block</li>
<li>location and size of each record</li>
</ul>
</li>
<li>需要注意的是：Records can be moved around within a page to keep them contiguous with no empty space between them; entry in the header must be updated.<br>Record pointers should not point directly to record — instead they should point to the entry for the record in header.</li>
</ul>
<h4><span id="organization-of-records-in-files">Organization of records in files</span></h4><ul>
<li>heap:有空余位置就插入<ul>
<li>每一个block都有一个entry，维护一个空闲块地图，记录这个块的空闲程度。</li>
</ul>
</li>
<li>sequential:插入元素维护一个次序</li>
<li>In a multitable clustering file organization records of several different relations can be stored in the same file。<ul>
<li>Motivation: store related records on the same block to minimize I&#x2F;O</li>
</ul>
</li>
<li>B+tree file organization</li>
<li>Hashing</li>
</ul>
<h2><span id="chapter14-indexing">chapter14-Indexing</span></h2><h3><span id="basic-concepts">Basic Concepts</span></h3><h3><span id="ordered-indices">Ordered Indices</span></h3><ul>
<li>Primary index:in a sequentially ordered file, the index whose search key specifies the sequential order of the file.</li>
<li>Secondary index（辅助索引）: an index whose search key specifies an order different from the sequential order of the file. Also called non-clustering index.</li>
<li>Dense index(稠密索引) — Index record appears for every search-key value in the file.</li>
<li>Sparse Index（稀疏索引）: contains index records for only some search-key values.</li>
</ul>
<h3><span id="b-tree-index">B+-Tree Index</span></h3><h4><span id="properties-of-b-tree">properties of B+-tree</span></h4><ul>
<li>All paths from root to leaf are of the same length</li>
<li>Inner node(not a root or a leaf): between [n&#x2F;2] and n children.</li>
<li>Leaf node: between [(n–1)&#x2F;2] and n–1 values</li>
<li>Special cases:<ul>
<li>If the root is not a leaf:<br> at least 2 children.</li>
<li>If the root is a leaf :<br> between 0 and (n–1)values.</li>
</ul>
</li>
</ul>
<h4><span id="b-tree-node-structure">B+-Tree Node Structure</span></h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database141.png" alt="database141" class="lazyload"></p>
<h4><span id="b-treeheight-and-size-estimation">B+-tree:height and size estimation</span></h4><ul>
<li>最关键的是找到fan-out,因为按照我们上面提到的B+Tree Node structure，每一个fan都是由serch key和指针决定。我们的fan_out就是由search key和指针的大小以及block size决定。</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database142.png" alt="database142" class="lazyload"></p>
<h4><span id="indexing-strings">Indexing strings</span></h4><ul>
<li>如果索引值为variable length strings，按照前面的思路我们可能得到不同的fanout。</li>
<li>解决：采用前缀压缩解决</li>
</ul>
<h4><span id="non-unique-search-keys">Non-Unique Search keys</span></h4><h4><span id="b-file-organization">B+-File Organization</span></h4><ul>
<li>B+-Tree File Organization:<ul>
<li>Leaf nodes in a B+-tree file organization store records, instead of pointers</li>
<li>Helps keep data records clustered even when there are insertions&#x2F;deletions&#x2F;updates</li>
</ul>
</li>
<li>Leaf nodes are still required to be half full<ul>
<li>Since records are larger than pointers, the maximum number of records that can be stored in a leaf node is less than the number of pointers in a nonleaf node.</li>
</ul>
</li>
<li>Insertion and deletion are handled in the same way as insertion and deletion of entries in a B+-tree index.</li>
</ul>
<h4><span id="indices-on-multiple-keys">Indices on Multiple Keys</span></h4><ul>
<li>Composite search keys are search keys containing more than one attribute。</li>
<li>大小的比较就根据属性的次序依次比较即可</li>
</ul>
<h3><span id="bulk-loading-and-bottom-up-build">Bulk Loading and Bottom-Up Build</span></h3><ul>
<li>将条目逐个插入B+树中，假设叶级无法装入内存，则每次需要1 IO，对于一次加载大量条目（批量加载）来说，这可能非常低效</li>
<li>选择1：insert in sorted order</li>
<li>选择2：Bottom-up build<ul>
<li>首先把所有索引排序</li>
<li>从叶子节点开始向上构造每一层</li>
<li>The built B+-tree is written to disk using sequential I&#x2F;O operations</li>
</ul>
</li>
<li>如果要批量插入较大规模的数据，我们可以直接合并为大的b+tree，然后使用bottom-up build方法构建。(其中原来的b+tree在磁盘中是连续存放的，所以我们归并时只要seek1次，然后连续读入block进行归并。最后构建好b+tree后再seek1次，并且通过block transfers写入磁盘)</li>
</ul>
<h3><span id="indexing-in-main-memory">Indexing in Main Memory</span></h3><ul>
<li>Random access in memory<ul>
<li>Much cheaper than on disk&#x2F;flash, but still expensive compared to cache read</li>
<li>Binary search for a key value within a large B+-tree node results in many cache misses</li>
<li>Data structures that make best use of cache preferable – cache conscious</li>
</ul>
</li>
<li>小节点的b+树适合缓存行的树比减少缓存缺失更可取</li>
<li>总结：优化磁盘访问采用大节点；优化缓存采用小节点的树，减小cache miss.</li>
</ul>
<h3><span id="indexing-on-flash">Indexing on Flash</span></h3><ul>
<li>Random I&#x2F;O cost much lower on flash</li>
<li>Write-optimized tree structures (i.e., LSM-tree) have been adapted to minimize page writes for flash-optimized search trees</li>
</ul>
<h3><span id="write-optimized-indices优化b树">Write optimized indices–优化B+树</span></h3><h4><span id="log-structured-merge-tree">Log Structured Merge Tree</span></h4><ul>
<li>结构<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database143.png" alt="database143" class="lazyload"><ul>
<li>records inserted first into in-memory tree(L0 tree)</li>
<li>内存里的B+tree满了的话，就写入磁盘中。此时b+tree的构建如果使用L0和L1就可以采用自下而上的构建方式。</li>
<li>当L1超过某个阈值以后merge into L2,并且新树的阈值是原来树的阈值的倍数。</li>
</ul>
</li>
<li>benefits<ul>
<li>减少IO次数，减少磁盘碎片化。</li>
<li>始终顺序I&#x2F;O操作。因为当使用LSM Tree的时候，数据先写到内存，满了再到磁盘，磁盘分级向下，始终是一个顺序的操作。</li>
</ul>
</li>
<li>drawbacks<ul>
<li>查询必须搜索多棵树</li>
<li>内容都要复制多次（因为merge的缘故）</li>
</ul>
</li>
<li>stepped merge index<ul>
<li>是传统的LSM tree的变体，每一个level在磁盘上都有k棵树。当k个索引处于同一层时，合并得到一颗层数加一的树。</li>
<li>所以我们通过延迟merge，使得写入更便宜，但是查询变得更贵了。</li>
<li>优化查询的一个方法是使用Bloom filter<ul>
<li>给每棵小树都配一个 Bloom Filter。查询一个 key 时，先检查 Bloom Filter，只有 Bloom filter 返回可能存在，才真正去访问磁盘文件。如果 Bloom filter 说肯定不存在，就可以跳过这个树，省下一次磁盘 I&#x2F;O。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><span id="buffer-tree">buffer tree</span></h4><ul>
<li>主要思想：B+树的每个内部节点都有一个缓冲区来存储插入</li>
<li>当缓冲区满时，插入操作将移动到较低级别。使用大缓冲区时，每次都会将许多记录移动到较低级别。每条记录的I&#x2F;O会相应地减少</li>
</ul>
<h2><span id="chapter15-query-processing">chapter15-Query Processing</span></h2><h3><span id="basic-steps-in-query-processing">Basic steps in query processing</span></h3><ul>
<li>by parser and translator to relational algebra expression</li>
<li>amongst all equivalent evaluation plans choose the one with the lowest cost</li>
<li>evaluation of the chosen plan</li>
</ul>
<h3><span id="measures-of-query-cost">measures of query cost</span></h3><ul>
<li>为了简便计算，我们只考虑number of transfeers and the number of seeks.</li>
<li>cost for b block transfers plus S seeks:$b * t_T+S * t_s$</li>
</ul>
<h3><span id="selection-operation">selection operation</span></h3><h4><span id="file-scan">file scan</span></h4><ul>
<li>线性扫描，Scan each file block and test all records to see whether they satisfy the selection condition.<br>worst cost &#x3D; br * tT + tS（假设连续存放，则只需要进行一次seek）br denotes number of blocks containing records from relation r</li>
<li>If selection is on a key attribute, can stop on finding record average cost &#x3D; (br &#x2F;2) tT + tS（如果数据没有连续存放则不能进行二分查找）</li>
</ul>
<h4><span id="selection-using-indices">selection using indices</span></h4><ul>
<li>Index scan – search algorithms that use an index</li>
<li>A2 (primary B+-tree index &#x2F; clustering B+-tree index, equality on key). Retrieve a single record that satisfies the corresponding equality condition.  Cost &#x3D; (hi + 1) * (tT + tS)</li>
<li>A3 (primary B+-tree index&#x2F; clustering B+-tree index, equality on nonkey) Retrieve multiple records. Records will be on consecutive blocks. Cost &#x3D; hi(tT + tS) + tS + tT* b</li>
<li>A4 (secondary B+-index on nonkey, equality).<br>Each of n matching records may be on a different block.(指针对应的记录) n pointers may be stored in m blocks. Cost &#x3D; (hi + m+ n) * (tT + tS)<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database151.png" alt="database151" class="lazyload"></li>
</ul>
<h4><span id="selections-involving-comparisons">selections involving comparisons</span></h4><ul>
<li>A5 (primary B+-index &#x2F; clustering B+-index index, comparison). (Relation is sorted on A)</li>
<li>For $\rho_{A \ge v}(r)$ use index to find first $tuple \ge v$ and scan relation sequentially from there. Cost is identical to the case of A3 → Cost&#x3D;hi*(tT + tS) + tS + tT* b<br>-For $\rho_{A \le v}(r)$ just scan relation sequentially till first tuple &gt; v; do not use index</li>
<li>A6 (secondary B+-tree index, comparison). $\rho_{A \ge v}(r)$ use index to find first index $entry \ge v$ and scan index sequentially from there, to find pointers to records.</li>
<li>$\rho_{A \le v}(r)$ just scan leaf pages of index finding pointers to records, till first entry &gt; v</li>
</ul>
<h3><span id="sorting">sorting</span></h3><h4><span id="external-sort-merge比较重要">external sort-merge(比较重要)</span></h4><ul>
<li>Let M denote memory size (in pages).Total number of runs : [br &#x2F;M].Total number of merge passes required: log M–1(br&#x2F;M).Block transfers for initial run creation as well as in each pass is 2br.</li>
<li>Cost of seeks: (simple version) During run generation: one seek to read each run and one seek to write each run.2[br &#x2F; M].During merge passes: one seek to read each run and one seek to write each run.Total number of seeks:2 [br &#x2F; M] + br (2 [logM-1(br &#x2F; M)] -1)</li>
<li>advanced version<ul>
<li>思想:1 block per run leads to too many seeks during merge Instead use bb buffer blocks per run:read &#x2F;write bb blocks at a time.</li>
<li>Total number of merge passes required: log [M&#x2F;bb]–1(br&#x2F;M)</li>
</ul>
</li>
</ul>
<h3><span id="join-operations">join operations</span></h3><h4><span id="nested-loop-join">Nested-Loop Join</span></h4><ul>
<li>在这个算法的情况下,我们利用循环嵌套逐个检查每一个tuple,每个tuple和每个tuple配对检查。</li>
<li>In the worst case, if there is enough memory only to hold one block of each relation, the estimated cost is nr*bs+ br block transfers, plus nr+ br seeks<br>（注意内存对于每个关系只能放一个block,所以每次外关系从磁盘传进内存，所以每次都要seek，总的为br seeks。而当外关系seek进来以后，每一个外关系的tuple都对应需要seek一次的内关系，然后进行block transfers）</li>
<li>如果内存足够大，能够将关系全部放入内存，block transfers:br+bs block seeks:2</li>
</ul>
<h4><span id="block-nested-loop-join">block nested-loop join</span></h4><ul>
<li>这个是循环嵌套的变体，我们首先将外关系的block与内关系的block配对，再在block内进行tuple的遍历配对。(所以算法会显示有四层循环)<ul>
<li>worst case:$br * bs+ br$ block transfers $ + 2*br$ seeks（和循环嵌套相比，因为我们站在block的视角，所以将nr替换为br）</li>
</ul>
</li>
<li>Use M-2 disk blocks as blocking unit for outer relations, where M &#x3D; memory size in blocks; use remaining two blocks to buffer inner relation and output.<ul>
<li>Cost &#x3D; [br &#x2F; (M-2)] * bs + br block transfers + 2 [br &#x2F; (M-2)] seeks.如果块的数量很多，那么cost&#x3D;bs+br block transfers +2 seeks</li>
</ul>
</li>
</ul>
<h4><span id="indexed-nested-loop-join">indexed nested-loop join</span></h4><ul>
<li>如果连接是等值连接或自然连接并且内关系的连接属性上存在索引，则索引查找可以替代文件扫描可以构建索引来计算连接。对于外关系r中的每个元组$t_r$，使用索引查找满足与元组$t_r$的连接条件的s中的元组。</li>
<li>Cost of the join: br(tT + tS) + nr*c(其中c是遍历索引和获取一个元组或r的所有匹配s元组的成本)</li>
</ul>
<h4><span id="merge-join">merge-join</span></h4><ul>
<li>只能适用于等值连接和自然连接（因为merge-join的操作核心就是基于关系之间链接的属性进行排序）</li>
<li>Each block needs to be read only once. assuming all tuples for any given value of the join attributes fit in memory.Thus the cost of merge join is: br + bs block transfers +[br&#x2F; bb]+ [bs&#x2F; bb]seeks（注意bb指的是缓冲块数，通常情况为1）</li>
<li>其实从最后的cost结果我们可以反过来发现，merge-join的本质其实就是通过sorted来减少我们比较的次数，从而减少transfers的次数。</li>
<li>假如buffer memory size为M pages,最小化cost:$br+bs+[br&#x2F;x_r]+[bs&#x2F;x_s]  (x_r+x_s&#x3D;M)$ answer:$x_r&#x3D;\sqrt{b_r}*M&#x2F;(\sqrt{b_r}+\sqrt{b_s});x_s&#x3D;\sqrt{b_s}*M&#x2F;(\sqrt{b_r}+\sqrt{b_s})$</li>
</ul>
<h4><span id="hash-join">hash join</span></h4><ul>
<li>Applicable for equi-joins and natural joins.</li>
<li>基本原理：<ul>
<li>哈希连接的核心思想是使用哈希表（Hash Table）来加速连接操作，其基本步骤分为两个阶段：</li>
<li>构建阶段（Build Phase）：<ul>
<li>选择较小的表（称为构建表，Build Table）作为输入。</li>
<li>对连接列计算哈希值，并构建哈希表（通常存储在内存中）。</li>
</ul>
</li>
<li>探测阶段（Probe Phase）：<ul>
<li>扫描较大的表（称为探测表，Probe Table）。</li>
<li>对探测表的连接列计算哈希值，并在哈希表中查找匹配项。</li>
<li>如果找到匹配，则输出连接结果。</li>
</ul>
</li>
</ul>
</li>
<li>分区哈希连接<ul>
<li>分区阶段：对构建表和探测表按照哈希值进行分区，再写入磁盘</li>
<li>连接阶段：逐个加载分区到内存，进行哈希连接</li>
</ul>
</li>
<li>cost of hash-join<ul>
<li>不需要recursive partition:$3 * (b_r+b_s)+4 * n_h$ block transfers+$2 * ([b_r&#x2F;b_b]+[b_s&#x2F;b_b])+2 * n_h$ seeks</li>
<li>解释:首先在分区阶段，我们从磁盘读入，分区后再写入消耗$2*(b_r&#x2F;b_b+b_s&#x2F;b_b)$ seeks,$2*(b_r+b_s)$ block transfers;在构建和探测阶段，逐个加载分区$b_r+b_s$ block transfers,分区占用的块数可能略多于br +bs，这是由于部分填充的块所致。访问这些部分填充的块可能会为每个关系增加最多2nh的开销，因为每个nh个分区中都可能存在一个需要写入和读回的部分填充块。</li>
</ul>
</li>
<li>recursive partitioning<ul>
<li>如果分区数n大于内存页数M，则需要递归分区(不再使用n个分区，而是使用M-1个分区来处理s。再使用不同的哈希函数对M-1个分区进行进一步划分。同样的方式处理关系r)</li>
<li>所以我们可以得到不使用recursive时的条件:$M \ge \frac{b_s}{M}+1&#x3D;n_h+1$（在这里我觉得前面的表述存在问题，应该是分区的大小大于内存页数，因为我们必须保证内存中能同时放下一个分区）</li>
</ul>
</li>
</ul>
<h2><span id="chapter16-query-optimization">chapter16-Query Optimization</span></h2><h3><span id="generating-equivalent-expressions">Generating equivalent expressions</span></h3><h4><span id="transformation-of-relational-expressions">transformation of relational expressions</span></h4><ul>
<li>Two relational algebra expressions are said to be equivalent if the two expressions generate the same set of tuples on every legal database instance</li>
<li><code>equivalence rules</code><ul>
<li>Conjunctive selection operations can be deconstructed（分解）into a sequence of individual selections.(如果我们拥有组合索引，或者根本就没有相对应的索引，我们就可以使用组合合取的选择方式)：$\rho_{\theta_1 \land \theta_2}(E)&#x3D;\rho_{\theta_1}(\rho_{\theta_2}(E))$</li>
<li>Selection operations are commutative（可交换的）</li>
<li>Only the last in a sequence of projection operations is needed, the others can be omitted（可省略的）</li>
<li>Selections can be combined with Cartesian products and theta joins</li>
<li>Theta-join operations (and natural joins) are commutative(可交换的)</li>
<li>Natural join operations are associative（可结合的）：$(E_1 \bowtie E_2) \bowtie E_3 &#x3D; E_1 \bowtie (E_2 \bowtie E_3)$</li>
<li>Theta joins are associative in the following manner:<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database161.png" alt="database161" class="lazyload"></li>
<li>selection distributes:<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database162.png" alt="database162" class="lazyload"></li>
<li>projection distributes</li>
<li>the equivalence rules about set<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database163.png" alt="database163" class="lazyload"></li>
</ul>
</li>
</ul>
<h3><span id="statictics-for-cost-estimation">statictics for cost estimation</span></h3><h4><span id="statistical-information-for-cost-estimation">statistical information for cost estimation</span></h4><ul>
<li>nr: number of tuples in relation r</li>
<li>br: number of blocks in relation r</li>
<li>lr: size of tuples in relation r</li>
<li>V(A,r): number of distinct values that appear in r for attribute A</li>
</ul>
<h4><span id="selection-size-estimation">selection size estimation</span></h4><ul>
<li>$\rho_{A&#x3D;v}(r)$<ul>
<li>$\frac{nr}{V(A,r)}$: estimate the number of tuples in r that satisfy the selection condition.</li>
</ul>
</li>
<li>$\rho_{A \le v}(r)$<ul>
<li>Let c denote the estimated number of tuples satisfying the condition.</li>
<li>$c&#x3D;n_r*\frac{v-min(A,r)}{max(A,r)-min(A,r)}$</li>
</ul>
</li>
<li><code>size estimation of complex selections</code><ul>
<li>The selectivity（中选率） of a condition $\theta_i$ is the probability that a tuple in the relation r satisfies $\theta_i$</li>
<li>conjunction:$\rho_{\theta_1 \land \theta_2….}(r)$.Thus, the result is $n_r$ *<br>$\frac{S_1S_2S_n}$</li>
<li>disjunction:$\rho_{\theta_1 \lor \theta_2….}(r)$.Thus, the result is $n_r <em>(1-(1-\frac{S_1}{nr})</em>(1-\frac{S_2}{nr})….)$</li>
</ul>
</li>
</ul>
<h4><span id="estimation-of-the-size-of-joins">Estimation of the size of joins</span></h4><p><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database164.png" alt="database164" class="lazyload"></p>
<h3><span id="choice-of-evaluation-plans">choice of evaluation plans</span></h3><h4><span id="cost-based-join-order-selection">cost-based join-order selection</span></h4><ul>
<li><p>想要找到最好的方式将n个表连接起来，我们有许多种选择方式。</p>
</li>
<li><p><code>Join Order Optimization Algorithm</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">procedure <span class="hljs-title">findbestplan</span><span class="hljs-params">(S)</span></span><br><span class="hljs-function">  <span class="hljs-title">if</span> <span class="hljs-params">(bestplan[S].cost  )</span></span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> bestplan[S]</span><br><span class="hljs-function">  <span class="hljs-comment">// else bestplan[S] has not been computed earlier, compute it now</span></span><br><span class="hljs-function">  <span class="hljs-title">if</span> <span class="hljs-params">(S contains only <span class="hljs-number">1</span> relation)</span></span><br><span class="hljs-function">    set bestplan[S].plan <span class="hljs-keyword">and</span> bestplan[S].cost based on the best way of accessing S <span class="hljs-keyword">using</span> selections on S <span class="hljs-keyword">and</span> <span class="hljs-title">indices</span> <span class="hljs-params">(<span class="hljs-keyword">if</span> any)</span> on S</span><br><span class="hljs-function">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> each non-empty subset S1 of S such that S1 !</span>= S<br>    P1= <span class="hljs-built_in">findbestplan</span>(S1)<br>    P2= <span class="hljs-built_in">findbestplan</span>(S - S1)<br>    <span class="hljs-keyword">for</span> each algorithm A <span class="hljs-keyword">for</span> joining results of P1 <span class="hljs-keyword">and</span> P2<br>      … compute plan <span class="hljs-keyword">and</span> cost of <span class="hljs-keyword">using</span> <span class="hljs-built_in">A</span> (see next page) ..<br>      <span class="hljs-keyword">if</span> cost &lt; bestplan[S].cost <br>          bestplan[S].cost = cost<br>          bestplan[S].plan = plan;<br>  <span class="hljs-keyword">return</span> bestplan[S]<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>cost of optimization</code></p>
<ul>
<li>在使用优化的动态规划中，时间复杂度变为$O(3^n)$</li>
<li>如果我们只考虑寻找最优的left-deep trees，那么时间复杂度变为$O(n*2^n)$</li>
</ul>
</li>
</ul>
<h3><span id="additional-optimization-techniques">Additional Optimization Techniques</span></h3><h4><span id="optimizing-nested-subqueries">Optimizing Nested Subqueries</span></h4><ul>
<li>通常将嵌套查询转化为连接，降低成本</li>
<li><code>半连接优化exists的嵌套子查询</code><ul>
<li>半连接本质上和连接的差距就是只满足一边的情况，所以就适合处理嵌套子查询(只用满足嵌套子查询的条件即可)<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database165.png" alt="database165" class="lazyload"></li>
<li>逆半连接可以用来优化:not exists的嵌套子查询</li>
</ul>
</li>
<li><code>处理更复杂的嵌套子查询，可能涉及分组使用聚合函数等操作</code><br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database166.png" alt="database166" class="lazyload"></li>
</ul>
<h4><span id="materialized-views">Materialized views</span></h4><ul>
<li>将传统的view实际存储</li>
<li>保持物化视图与底层数据同步的任务称为物化视图维护</li>
<li>Materialized views can be maintained by 、recomputation on every update. A better option is to use <strong>incremental view maintenance</strong></li>
</ul>
<h2><span id="chapter-17-transactions">Chapter 17-Transactions</span></h2><h3><span id="transaction-concept">Transaction Concept</span></h3><ul>
<li>事务是程序执行的单元，它访问并可能更新各种数据项</li>
<li>性质(ACID)<ul>
<li>原子性(atomicity)：事务包含的数据库操作，要么全部做，要么都不做。</li>
<li>一致性(consistency)：事务执行之前和之后，数据库的完整性没有改变。</li>
<li>隔离性(isolation)：事务执行过程中，其他事务不能被其他事务干扰。</li>
<li>持久性(Durability)：在事务成功完成之后，它对数据库所做的更改会持续存在，即使出现系统故障。</li>
</ul>
</li>
</ul>
<h3><span id="a-simple-transaction-model">A simple transaction model</span></h3><ul>
<li><p>事务对于数据的操作基于两个操作：read 和 write</p>
</li>
<li><p>example of fund transfer</p>
<ul>
<li>事务:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span> read(A)<br><span class="hljs-number">2.</span> A :<span class="hljs-operator">=</span> A – <span class="hljs-number">50</span><br><span class="hljs-number">3.</span> write(A)<br><span class="hljs-comment">-----------------------</span><br><span class="hljs-number">4.</span> read(B)<br><span class="hljs-number">5.</span> B :<span class="hljs-operator">=</span> B <span class="hljs-operator">+</span> <span class="hljs-number">50</span><br><span class="hljs-number">6.</span> write(B)<br></code></pre></td></tr></table></figure>

<ul>
<li>原子性要求：系统应确保未完全执行的交易更新不会反映在数据库中</li>
<li>持久性要求：一旦用户已被告知交易已完成（即，50美元的转账已经完成），则必须对数据库进行更新，即使发生软件或硬件故障，这些更新也必须持续。</li>
</ul>
</li>
</ul>
<h4><span id="transaction-state">Transaction State</span></h4><ul>
<li>Active：初始状态</li>
<li>Partially commited</li>
<li>Failed</li>
<li>Aborted：事务回滚后，数据库恢复到事务开始前的状态。事务被中止后有两种选择：重新启动事务和终止事务</li>
<li>Commited</li>
</ul>
<h3><span id="concurrent-executions">Concurrent Executions</span></h3><ul>
<li>系统允许多个事务并发执行<ul>
<li>advantages：提高了事务的吞吐量</li>
<li>advantages：减少了事务处理的平均响应时间：短事务不必等待长事务。</li>
</ul>
</li>
</ul>
<h4><span id="anomalies-in-concurrent-executions">Anomalies in Concurrent Executions</span></h4><ul>
<li>Lost Update（丢失修改）：几乎同时两个事务对同一个数据修改时，另外一个事务看见的数据仍然是旧的数据，所以最终丢失了修改。</li>
<li>Dirty Read（脏读）：当一个事务进行修改并将数据写出去后，此时另一个事务读到的是第一个事务的脏数据，但是在后面第一个事务roll back。也就是一个事务读了另一个未提交事务的数据就叫做脏读。</li>
<li>Unrepeatable Read（不可重复读）：当一个事务读到数据后，此时另一个事务修改了数据，那么第一个事务读到的数据可能就不再是同一个数据。</li>
<li>Phantom Problem（幽灵问题）：其实也是和不可重复读异曲同工，只是现在是整个表出现了更新，对于表查询结果前后出现差异。</li>
</ul>
<h4><span id="schedules">Schedules</span></h4><ul>
<li>调度程序-一系列指令，用于指定并发事务的指令执行顺序</li>
</ul>
<h3><span id="serializability可串行化">Serializability（可串行化）</span></h3><ul>
<li>A (possibly concurrent) schedule is serializable if it is equivalent to a serial schedule.</li>
</ul>
<h4><span id="conflict-serializability">conflict serializability</span></h4><ul>
<li>利用前驱图检测可串行化（如果两个事务冲突，我们从Ti到Tj绘制一条弧线，Ti访问了冲突发生较早的数据项）</li>
<li>只要前驱图不存在环，那么就是冲突可串行化的。并且等价的串行可以通过拓扑排序得到。</li>
<li>example<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database171.png" alt="database171" class="lazyload"></li>
</ul>
<h4><span id="view-serializability">View Serializability</span></h4><ul>
<li>设S和S‘是具有相同事务集的两个调度。如果满足下列三个条件，对于每个数据项Q，S和S’是视图等价的。<ul>
<li>1.如果在调度S中，事务Ti读取了Q的初始值，则在调度S‘中，事务Ti也必须读取Q的初始值。</li>
<li>2.如果在调度S中，事务Ti执行了读取(Q)，而该值是由事务Tj（如果有）产生的，那么在调度S’中，事务Ti也必须读取由事务Tj的相同写入(Q)操作产生的Q的值。</li>
<li>3.在调度S中执行最终写入(Q)操作的事务（如果有）也必须在调度S‘中执行最终写入(Q)操作。</li>
</ul>
</li>
<li>如果一个调度视图等价于一个串行调度则说明它是view serializability。</li>
</ul>
<h4><span id="recoverable-schedules">Recoverable Schedules</span></h4><ul>
<li>可恢复的计划（可恢复调度）——如果事务Tj读取了之前由事务Ti写入的数据项，那么Ti的提交操作出现在Tj的提交操作之前</li>
</ul>
<h4><span id="cascading-rollbacks">Cascading Rollbacks</span></h4><ul>
<li>级联回滚-单个事务失败会导致一系列事务回滚。考虑以下时间表，其中没有任何事务已提交（因此该时间表是可恢复的）<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database172.png" alt="database172" class="lazyload"></li>
<li>假设事务T1失败，那么事务T2和T3都将roll back。（可能导致大量工作取消）</li>
</ul>
<h3><span id="transaction-isolation-levels">Transaction Isolation Levels</span></h3><ul>
<li>Serializable</li>
<li>Repeatable Read:only commited records to be read，对同一记录的重复读取必须返回相同的值。但是，事务可能不是串行的–它可能找到由事务插入的某些记录，但找不到其他记录。</li>
<li>Read Committed：只能读取已提交的记录，但连续读取记录可能会返回不同的（但已提交的）值</li>
<li>Read Uncommitted：可以读取未提交的记录。</li>
</ul>
<h2><span id="chapter-18-concurrency-control">Chapter 18-Concurrency Control</span></h2><h3><span id="lock-based-protocols">Lock-Based Protocols</span></h3><h4><span id="the-two-phase-locking-2pl-protocol">The Two-Phase Locking (2PL) Protocol</span></h4><ul>
<li>Phase 1:Growoing Phase:事务获取锁，事务不能释放锁,其中Lock point为事务获取最后一个锁的时刻。</li>
<li>Phase 2:Shrinking Phase:事务释放锁，事务不能获取锁</li>
<li>两阶段锁定协议保证了序列化，可以证明事务按照其锁定点的顺序进行序列化</li>
</ul>
<h5><span id="利用前驱图反证协议的正确性">利用前驱图反证协议的正确性</span></h5><ul>
<li>我们现在研究两个事务，Ti,Tj.假设在前驱图上Ti有一条弧线指向Tj</li>
<li>如图所示<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database173.png" alt="database173" class="lazyload"><br>解释：因为两者发生冲突，根据Two-Phase Locking协议，当Ti进行phase2的时候，Tj才能加锁。所以两者的lock point在时间上存在先后顺序。我们可以显然得到前驱图上面没有环状结构，所以一定是conflict serializable。</li>
</ul>
<h4><span id="继续探究2pl">继续探究2PL</span></h4><ul>
<li>扩展基本的两阶段锁定（基本两阶段封锁）以确保恢复自由，防止级联回滚。<ul>
<li>strict two-phase locking（严格两阶段封锁）：事务必须持有其所有exclusive锁直到提交或回滚。确保恢复并避免级联回滚。</li>
<li>rigorous two-phase locking（强两阶段封锁）：事务必须持有所有锁直到提交或回滚。事务可以按照提交的顺序进行序列化。</li>
</ul>
</li>
<li>Two-phase locking is not a necessary condition for serializability<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database181.png" alt="database181" class="lazyload"><br><code>如上图所示，上面例子的调度是conflict serializable，但是对于事务1并没有采用两阶段封锁协议，因为我们在释放锁后又重新获得了锁</code></li>
<li>两阶段封锁协议还可以进行扩展，with lock conversion<ul>
<li>First Phase:<br>can acquire a lock-S or lock-X on a data item<br>can convert a lock-S to a lock-X<br>(lock-upgrade)</li>
<li>Second Phase:<br>can release a lock-S or lock-X<br>can convert a lock-X to a lock-S</li>
</ul>
</li>
</ul>
<h3><span id="implementation-of-locking">implementation of locking</span></h3><h4><span id="lock-table">Lock Table</span></h4><ul>
<li>Lock Table是实现Lock manager的重要数据结构，它存储了所有锁的信息。<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database182.png" alt="database182" class="lazyload"></li>
<li>每个记录的 id 可以放进哈希表。<ul>
<li>如这里记录 123, T1、T8 获得了 S 锁，但 T2 在等待获得 X 锁。</li>
</ul>
</li>
<li>T1: lock-X(D) 通过 D 的 id 找到哈希表上的项，在对应项上增加。根据是否相容决定是获得锁还是等待。<br>unlock 类似，先找到对应的数据，拿掉对应的项。同时看后续的项是否可以获得锁。</li>
<li>如果一个事务 commit, 需要放掉所有的锁，我们需要去找。因此我们还需要一个事务的表，标明每个事务所用的锁。</li>
</ul>
<h4><span id="deadlock-handling">Deadlock Handling</span></h4><h5><span id="deadlock">Deadlock</span></h5><p><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database183.png" alt="database183" class="lazyload"></p>
<ul>
<li>两个事务互相等待对方释放锁，每个事务只获取了一部分的锁，没能获取所有的锁。</li>
<li><strong>Two-phase locking does not ensure freedom from deadlocks</strong></li>
</ul>
<h5><span id="handling">Handling</span></h5><ul>
<li>Deadlock prevention protocols ensure that the system will never enter into a deadlock state. Some prevention strategies :<ul>
<li>Require that each transaction locks all its data items before it begins execution (predeclaration).一次获得所有的锁</li>
<li>Impose partial ordering of all data items and require that a transaction can lock data items only in the order specified by the partial order (graph-based protocol).</li>
</ul>
</li>
<li>我们也可以在等待时间上面做文章：事务只等待指定时间的锁定。之后，等待超时，事务回滚。</li>
</ul>
<h4><span id="deadlock-detection">Deadlock Detection</span></h4><ul>
<li>Deadlocks可以用wait-for graph描述：顶点表示所有事务，对于边：如果Ti→Tj位于E中，则存在从Ti到Tj的有向边，这意味着Ti正在等待Tj释放数据项。（边的意义主要表示的是等待关系，而前面提及的前驱图的边的关系表示的是执行顺序）</li>
<li>当Ti请求Tj当前持有的数据项时，会在等待图中插入边Ti Tj。只有当Tj不再持有Ti需要的数据项时，才会删除这条边。</li>
<li>只有当等待图中存在循环时，系统才会处于死锁状态。必须定期调用死锁检测算法来查找循环。</li>
</ul>
<h4><span id="deadlock-recovery">Deadlock Recovery</span></h4><ul>
<li>检测到死锁时：某些事务将不得不回滚（成为受害者）以打破死锁。选择将产生最低成本的事务作为受害者。</li>
</ul>
<h4><span id="graph-based-protocols">Graph-Based Protocols</span></h4><h5><span id="tree-protocol">Tree Protocol</span></h5><ul>
<li>The tree-protocol is a simple kind of graph protocol.<ul>
<li>Only exclusive locks are allowed.只有这种锁。</li>
<li>The first lock by Ti may be on any data item. Subsequently, a data Q can be locked by Ti only if the parent of Q is currently locked by Ti.第一个锁可以放任意地方，后面的锁只能在父节点锁住时才能往下锁。</li>
<li>Data items may be unlocked at any time.</li>
<li>A data item that has been locked and unlocked by Ti cannot subsequently be relocked by Ti.放了之后不能再加锁了。</li>
</ul>
</li>
<li>The tree protocol ensures conflict serializability as well as freedom from<br>deadlock.</li>
</ul>
<h3><span id="multiple-granularity">Multiple Granularity</span></h3><ul>
<li>可以锁在记录上(如 update table set …;)，也可以锁在整个表上(如 select * from table;)。</li>
<li>Granularity of locking (level in tree where locking is done):<ul>
<li>fine granularity（细粒度） (lower in tree): high concurrency, high locking overhead</li>
<li>coarse granularity（粗粒度） (higher in tree): low locking overhead, low concurrency</li>
</ul>
</li>
</ul>
<h4><span id="level">level</span></h4><ul>
<li>自上而下的level:<ul>
<li>database</li>
<li>area</li>
<li>File</li>
<li>record</li>
</ul>
</li>
</ul>
<h4><span id="intention-lock-modes">Intention lock Modes</span></h4><ul>
<li><strong>intention-shared (IS)</strong>: indicates explicit locking at a lower level of the tree but <strong>only with shared locks</strong>.</li>
<li><strong>intention-exclusive (IX)</strong>: indicates explicit locking at a lower level with <strong>exclusive or shared locks</strong></li>
<li><strong>shared and intention-exclusive (SIX)</strong>: the subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.</li>
<li>如果一个事务要给一个记录加 S 锁，那也要在表上加 IS 锁。（意向共享锁）</li>
<li>如果一个事务要给一个记录加 X 锁，那也要在表上加 IX 锁。（意向排他锁）</li>
<li>SIX 锁是 S 和 IX 锁的结合。要读整个表，但可能对其中某些记录进行修改。（共享意向排他）</li>
<li>这样当我们想向一个表上 S 锁时，发现表上有 IX 锁，这样我们很快就发现了冲突，需要等待。IS 和 IX 是不冲突的。在表上是不冲突的，可能在记录上冲突（即对一个记录又读又写，冲突发生在记录层面而非表）。</li>
<li>由上面的分析，其实我们可以得到下面的相容矩阵<br><img data-fancybox="gallery" data-sizes="auto" data-src="/./adsphoto/database184.png" alt="database184" class="lazyload"></li>
</ul>
<h3><span id="insert-and-delete-operation">Insert and Delete Operation</span></h3><script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_page_pv">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

	</article>

	 
    <div class="kira-post-copyright">
        <strong>本文作者：</strong>Lane<br>
        <strong>本文链接：</strong><a href="https://lakerswillwin.github.io/2025/02/17/database/" title="https:&#x2F;&#x2F;lakerswillwin.github.io&#x2F;2025&#x2F;02&#x2F;17&#x2F;database&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;lakerswillwin.github.io&#x2F;2025&#x2F;02&#x2F;17&#x2F;database&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			  
			<!-- 先找到与当前文字相同的目录 -->
			                                    
			<!-- 在找到当前文章所在的 index -->
			                                            
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2025/01/14/oop/"> 面向对象程序设计</a>
			</div>
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2025/02/18/computersystem/"> 计算机体系结构</a>
			</div>
			                                                
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/cs%E8%AF%BE%E7%A8%8B/">cs课程</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/C/" rel="tag">C++</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
